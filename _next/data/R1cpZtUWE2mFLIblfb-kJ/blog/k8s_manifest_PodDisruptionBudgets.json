{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var l=Object.create;var s=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var h=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var o=i=>s(i,\"__esModule\",{value:!0});var m=(i,n)=>()=>(n||i((n={exports:{}}).exports,n),n.exports),g=(i,n)=>{o(i);for(var t in n)s(i,t,{get:n[t],enumerable:!0})},y=(i,n,t)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of p(n))!u.call(i,a)&&a!==\"default\"&&s(i,a,{get:()=>n[a],enumerable:!(t=c(n,a))||t.enumerable});return i},f=i=>y(o(s(i!=null?l(h(i)):{},\"default\",i&&i.__esModule&&\"default\"in i?{get:()=>i.default,enumerable:!0}:{value:i,enumerable:!0})),i);var d=m((D,r)=>{r.exports=_jsx_runtime});var w={};g(w,{default:()=>b,frontmatter:()=>P});var e=f(d()),P={title:\"K8S manifest - PodDisruptionBudgets\",date:new Date(168437166e4),lastmod:\"2023-05-18\",tags:[\"kubernetes\"],draft:!1,summary:\"\",layout:\"PostSimple\"};function v(i={}){let{wrapper:n}=i.components||{};return n?(0,e.jsx)(n,Object.assign({},i,{children:(0,e.jsx)(t,{})})):t();function t(){let a=Object.assign({h3:\"h3\",a:\"a\",span:\"span\",p:\"p\",h4:\"h4\",ol:\"ol\",li:\"li\"},i.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(a.h3,{id:\"is-a-pvc-created-for-every-pod-deployment\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#is-a-pvc-created-for-every-pod-deployment\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Is a PVC created for every Pod deployment?\"]}),(0,e.jsx)(a.p,{children:\"In Kubernetes, a PersistentVolumeClaim (PVC) is typically created before a Pod is deployed, although it is not a strict requirement. The lifecycle of PVCs and Pods can be decoupled, allowing PVCs to exist independently and be claimed by Pods at a later time.\"}),(0,e.jsx)(a.p,{children:\"Here are a few scenarios regarding the creation and timing of PVCs and Pods:\"}),(0,e.jsx)(a.p,{children:\"Pre-provisioned PVC: In some cases, PVCs may be pre-provisioned by a cluster administrator or an infrastructure team. These PVCs are created beforehand and made available for users to claim when deploying Pods. The PVCs can be claimed by Pods during their deployment, and the Pod can start using the associated storage immediately.\"}),(0,e.jsx)(a.p,{children:\"Dynamic Provisioning: Kubernetes also supports dynamic provisioning of PVCs. When a Pod specification includes a PVC, and the cluster has a StorageClass configured to enable dynamic provisioning, the PVC is automatically created when the Pod is deployed. The dynamic provisioning process involves creating the PVC and binding it to an available PersistentVolume (PV) that matches the requested storage class, capacity, and access mode.\"}),(0,e.jsx)(a.p,{children:\"PVC Claiming an Existing PV: If a PersistentVolume already exists, a PVC can claim it directly by matching the required storage class, capacity, and access mode. In this case, the PVC is created before the Pod, and the Pod specifies the pre-existing PVC in its specification.\"}),(0,e.jsx)(a.p,{children:\"It's important to note that the availability of a PVC for a Pod depends on various factors, such as the state of the PVC and the matching criteria defined in the Pod's volume specification. Kubernetes ensures that the PVC is bound to a suitable PV before allowing the Pod to use it, providing the requested storage resources to the Pod when it is scheduled.\"}),(0,e.jsx)(a.p,{children:\"In summary, while PVCs are often created before Pods, they can also be created dynamically during Pod deployment or claim pre-existing PVs. The exact timing depends on the specific use case, configuration, and requirements of the application and the underlying storage infrastructure.\"}),(0,e.jsx)(a.p,{children:\"Pre-provisioned PVC: Real-world use case: In a large organization, the IT infrastructure team pre-provisions PVCs with specific storage capacity and access modes to meet the anticipated needs of different teams and applications. Each team or application can claim the pre-provisioned PVCs as needed when deploying their Pods. This approach ensures efficient resource utilization and allows teams to quickly access and utilize storage resources without going through the provisioning process for each Pod deployment.\"}),(0,e.jsx)(a.p,{children:\"Dynamic Provisioning: Real-world use case: In a cloud-native environment, an application experiences varying demands for storage resources as the workload scales up or down. Dynamic provisioning allows the application to request PVCs as needed when Pods are deployed. For example, an e-commerce application may dynamically provision PVCs to handle increased storage requirements during peak shopping seasons. Dynamic provisioning enables efficient resource allocation and eliminates the need for manual intervention, ensuring storage capacity scales with the application's demands.\"}),(0,e.jsx)(a.p,{children:\"PVC Claiming an Existing PV: Real-world use case: In scenarios where specific storage resources are required, such as a dedicated storage array with specific performance characteristics or compliance requirements, administrators may provision PVs in advance. PVCs can then be created to claim these pre-existing PVs. This approach is suitable for applications that require access to a specific storage system or have stringent data management or compliance needs. The PVC claims the existing PV to provide the desired storage resources to the Pod without the need for additional provisioning.\"}),(0,e.jsx)(a.p,{children:\"Each of these PVC provisioning approaches caters to different scenarios and requirements. Pre-provisioned PVCs are suitable for situations where storage resources are known in advance and can be allocated ahead of time. Dynamic provisioning allows for on-demand creation of PVCs, ensuring efficient utilization of storage resources based on workload demands. PVC claiming an existing PV enables the use of dedicated or specialized storage systems that have already been provisioned in the environment.\"}),(0,e.jsxs)(a.h4,{id:\"reason-why-replicaset-or-deployment-cant-define-poddisruptionbudgets-pdbs\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#reason-why-replicaset-or-deployment-cant-define-poddisruptionbudgets-pdbs\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Reason why ReplicaSet or Deployment can't define PodDisruptionBudgets (PDBs):\"]}),(0,e.jsx)(a.p,{children:\"ReplicaSets and Deployments are higher-level resources in Kubernetes that manage the desired number of replicas of Pods. They focus on maintaining the desired replica count and managing the lifecycle of the Pods. However, they do not directly provide the ability to define PodDisruptionBudgets (PDBs). Here's why:\"}),(0,e.jsxs)(a.ol,{children:[(0,e.jsx)(a.li,{children:(0,e.jsx)(a.p,{children:\"Granularity: ReplicaSets and Deployments manage multiple Pods collectively, ensuring the desired number of replicas are running at all times. They do not have the granular visibility into individual Pods required to define availability constraints on a per-Pod basis.\"})}),(0,e.jsx)(a.li,{children:(0,e.jsx)(a.p,{children:\"Homogeneity: ReplicaSets and Deployments are designed to manage identical replicas of Pods. They assume that all replicas are interchangeable and can be scaled up or down as a group. Defining availability constraints on individual Pods within a ReplicaSet or Deployment would go against this assumption of uniformity.\"})}),(0,e.jsx)(a.li,{children:(0,e.jsx)(a.p,{children:\"Scaling and Rolling Updates: ReplicaSets and Deployments handle scaling operations and rolling updates by creating and terminating Pods incrementally. During scaling or updates, the Pod count may temporarily go below the desired replica count. This can conflict with the constraints defined in a PodDisruptionBudget, as PDBs aim to maintain a minimum number of available Pods at all times.\"})})]}),(0,e.jsx)(a.p,{children:\"To address availability concerns at the Pod level, Kubernetes provides the StatefulSet resource. StatefulSets are designed for managing stateful applications and support the use of PodDisruptionBudgets. StatefulSets maintain a fixed identity for each Pod, allowing for ordered scaling and updates while ensuring availability constraints defined in PDBs are honored.\"}),(0,e.jsx)(a.p,{children:\"In summary, while ReplicaSets and Deployments are not equipped to define PodDisruptionBudgets, StatefulSets are a more suitable choice when availability constraints at the Pod level are required. StatefulSets provide the necessary features and guarantees to ensure high availability and orderly disruption management for stateful applications.\"}),(0,e.jsxs)(a.h4,{id:\"explain-why-you-need-a-pdb-when-you-have-a-replicaset-or-deployment\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#explain-why-you-need-a-pdb-when-you-have-a-replicaset-or-deployment\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Explain why you need a PDB when you have a replicaset or deployment\"]}),(0,e.jsx)(a.p,{children:\"PodDisruptionBudgets (PDBs) are necessary even when using ReplicaSets or Deployments because they provide an additional layer of control and availability management beyond what ReplicaSets or Deployments alone offer.\"}),(0,e.jsx)(a.p,{children:\"While ReplicaSets and Deployments ensure the desired number of replica Pods are running and handle scaling and rolling updates, they do not directly address the availability constraints during disruptions or maintenance activities. This is where PDBs come into play. PDBs define availability policies, specifying the minimum number of available Pods during voluntary or involuntary disruptions.\"}),(0,e.jsx)(a.p,{children:\"By using PDBs in conjunction with ReplicaSets or Deployments, you can ensure that the desired availability and fault tolerance requirements are met. PDBs allow you to set constraints on the number of Pods that can be simultaneously unavailable, providing safeguards against potential downtime or service interruptions. This ensures that a minimum number of Pods remain available to serve requests, even during maintenance operations or unexpected failures.\"}),(0,e.jsx)(a.p,{children:\"PDBs help to achieve a balanced approach between availability and necessary maintenance activities. They allow you to perform rolling updates or scale down operations while ensuring that a sufficient number of Pods are available to maintain the required level of service. This helps to prevent disruptions to the application or service, enabling smoother maintenance processes and improved overall reliability.\"}),(0,e.jsx)(a.p,{children:\"In summary, while ReplicaSets and Deployments handle scaling and rolling updates, PDBs add an additional layer of control by defining availability constraints during disruptions. Together, they provide a comprehensive approach to managing replicas, scaling, and maintaining availability, ensuring robust and uninterrupted operation of your applications in Kubernetes clusters.\"})]})}}var b=v;return w;})();\n;return Component;","toc":[{"value":"Is a PVC created for every Pod deployment?","url":"#is-a-pvc-created-for-every-pod-deployment","depth":3},{"value":"Reason why ReplicaSet or Deployment can't define PodDisruptionBudgets (PDBs):","url":"#reason-why-replicaset-or-deployment-cant-define-poddisruptionbudgets-pdbs","depth":4},{"value":"Explain why you need a PDB when you have a replicaset or deployment","url":"#explain-why-you-need-a-pdb-when-you-have-a-replicaset-or-deployment","depth":4}],"frontMatter":{"readingTime":{"text":"7 min read","minutes":6.075,"time":364500,"words":1215},"slug":"k8s_manifest_PodDisruptionBudgets","fileName":"k8s_manifest_PodDisruptionBudgets.mdx","title":"K8S manifest - PodDisruptionBudgets","date":"2023-05-18T01:01:00.000Z","lastmod":"2023-05-18","tags":["kubernetes"],"draft":false,"summary":"","layout":"PostSimple"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.155,"time":9300,"words":31},"slug":["default"],"fileName":"default.md","name":"demian11k","avatar":"/static/images/avatar.png","email":"demian11k@gmail.com","github":"https://github.com/demian9k","date":null}],"prev":{"title":"K8S manifest - DaemonSet","date":"2023-05-16T04:03:00.000Z","lastmod":"2023-05-16","tags":["kubernetes"],"draft":false,"summary":"","layout":"PostSimple","slug":"k8s_manifest-DaemonSet"},"next":{"title":"K8S manifests examples 1 - hello","date":"2023-05-22T01:01:00.000Z","lastmod":"2023-05-22","tags":["kubernetes"],"draft":false,"summary":"","layout":"PostSimple","slug":"k8s_manifests_examples_1-hello"}},"__N_SSG":true}