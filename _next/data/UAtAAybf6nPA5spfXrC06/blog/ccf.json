{"pageProps":{"post":{"mdxSource":"var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var s=e=>r(e,\"__esModule\",{value:!0});var m=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),f=(e,n)=>{s(e);for(var i in n)r(e,i,{get:n[i],enumerable:!0})},b=(e,n,i)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let t of h(n))!u.call(e,t)&&t!==\"default\"&&r(e,t,{get:()=>n[t],enumerable:!(i=l(n,t))||i.enumerable});return e},g=e=>b(s(r(e!=null?d(p(e)):{},\"default\",e&&e.__esModule&&\"default\"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var c=m((k,o)=>{o.exports=_jsx_runtime});var T={};f(T,{default:()=>w,frontmatter:()=>v});var a=g(c()),v={title:\"favorite article links\",date:new Date(167789874e4),lastmod:\"2023-03-04\",tags:[\"favorite\"],draft:!0,summary:\"\",layout:\"PostSimple\"};function y(e={}){let{wrapper:n}=e.components||{};return n?(0,a.jsx)(n,Object.assign({},e,{children:(0,a.jsx)(i,{})})):i();function i(){let t=Object.assign({p:\"p\"},e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:\"There are several other approaches to solving transactional problems in a server per database environment beyond saga patterns, two-phase commits, and event-sourcing.\"}),(0,a.jsx)(t.p,{children:\"Here are some common ones:\"}),(0,a.jsx)(t.p,{children:\"Application-level retries: The application can be designed to retry a failed transaction for a certain number of times before giving up. This approach works well for transient errors that may occur due to network issues or server overload.\"}),(0,a.jsx)(t.p,{children:\"Optimistic concurrency control: This approach involves adding a version number or a timestamp to each row in the database. When a transaction updates a row, the version number or timestamp is checked to ensure that it hasn't been modified by another transaction in the meantime. If the check fails, the transaction is rolled back and retried.\"}),(0,a.jsx)(t.p,{children:\"Sharding: Sharding is a technique for horizontally partitioning a database across multiple servers. Each server is responsible for a subset of the data, which can help reduce contention and improve performance. Sharding can also help isolate transactions to specific servers, reducing the need for distributed transactions.\"}),(0,a.jsx)(t.p,{children:\"Atomic batch updates: If multiple updates need to be performed as part of a single transaction, they can be grouped together into a batch and executed as a single atomic operation. This approach can help reduce the chances of partial updates and improve performance.\"}),(0,a.jsx)(t.p,{children:\"Queue-based processing: Instead of directly updating the database, transactions can be queued for processing by a background process. The background process can then execute the transaction and handle any failures or retries.\"}),(0,a.jsx)(t.p,{children:\"Compensation transactions: This approach involves executing a series of compensating transactions to undo the effects of a failed transaction. This can help maintain consistency in the database and avoid the need for full rollbacks.\"}),(0,a.jsx)(t.p,{children:\"Retryable writes: Similar to application-level retries, retryable writes involve retrying a failed write operation until it succeeds. This can be achieved by adding a unique identifier to each write operation and using that identifier to detect duplicate writes.\"}),(0,a.jsx)(t.p,{children:\"These approaches can be combined in various ways to achieve different levels of transactional consistency and fault tolerance.\"}),(0,a.jsx)(t.p,{children:\"Consistent hashing: Consistent hashing is a technique for distributing data across a cluster of servers. Each server is responsible for a range of keys, and the range can be adjusted dynamically as servers are added or removed from the cluster. This can help reduce the impact of server failures on the overall system.\"}),(0,a.jsx)(t.p,{children:\"Read replicas: Read replicas are copies of a database that are synchronized with the master database. They can be used to offload read requests from the master database and improve read performance. However, since the replicas are eventually consistent, they may not be suitable for all use cases.\"}),(0,a.jsx)(t.p,{children:\"Snapshot isolation: Snapshot isolation is a technique for ensuring consistency in a database by isolating each transaction from others. When a transaction begins, it takes a snapshot of the database and uses that snapshot for all subsequent reads. This ensures that the transaction sees a consistent view of the database, even if other transactions are modifying it at the same time.\"}),(0,a.jsx)(t.p,{children:\"Application-level partitioning: Application-level partitioning involves dividing a large database into smaller, more manageable partitions based on some application-specific criteria. Each partition can be managed independently, which can help reduce contention and improve performance.\"}),(0,a.jsx)(t.p,{children:\"Write-ahead logging: Write-ahead logging is a technique for ensuring durability in a database by logging all changes before they are applied to the database. This allows the system to recover from failures by replaying the log.\"}),(0,a.jsx)(t.p,{children:\"Conflict-free replicated data types (CRDTs): CRDTs are data structures that are designed to be replicated across multiple servers without conflicts. They can be used to ensure consistency in distributed databases and reduce the need for expensive coordination mechanisms.\"})]})}}var w=y;return T;})();\n;return Component;","toc":[],"frontMatter":{"readingTime":{"text":"4 min read","minutes":3.095,"time":185700,"words":619},"slug":"ccf","fileName":"ccf.mdx","title":"favorite article links","date":"2023-03-04T02:59:00.000Z","lastmod":"2023-03-04","tags":["favorite"],"draft":true,"summary":"","layout":"PostSimple"}},"authorDetails":[{"readingTime":{"text":"1 min read","minutes":0.155,"time":9300,"words":31},"slug":["default"],"fileName":"default.md","name":"demian11k","avatar":"/static/images/avatar.png","email":"demian11k@gmail.com","github":"https://github.com/demian9k","date":null}],"prev":{"title":"gorm-delete","date":"2023-11-23T22:11:33.000Z","lastmod":"2023-11-26","tags":["go","orm"],"draft":false,"summary":"","layout":"PostSimple","canonicalUrl":"https://demian9k.github.io/blog/gorm-delete/","slug":"gorm-delete"},"next":null},"__N_SSG":true}